#pragma once

#include <cstdint>
#include <vector>

#include "util/common.h"
#include "util/macros.h"

namespace tpl {

namespace ast {
class Type;
}  // namespace ast

namespace vm {

using RegisterId = u16;
using FunctionId = u16;

/**
 * A register in a function's frame. A register can represent either a local
 * variable, a return value or a parameter value. They have fixed size and
 * position in an execution frame, and are mutable during the execution of the
 * function. The virtual machine ensures that a register's memory always has the
 * correct alignment deemed by its type and the machine architecture. After
 * construction, register's become read-only.
 */
class Register {
 public:
  static constexpr const RegisterId kInvalidIndex =
      std::numeric_limits<RegisterId>::max();

  Register(RegisterId index, std::string name, ast::Type *type,
           std::size_t offset, bool is_param)
      : name_(std::move(name)),
        type_(type),
        offset_(offset),
        id_(index),
        is_param_(is_param) {
    TPL_ASSERT(index >= 0, "Index must be positive!");
  }

  std::size_t Size() const;

  const std::string &name() const { return name_; }

  const ast::Type *type() const { return type_; }

  RegisterId id() const { return id_; }

  std::size_t offset() const { return offset_; }

  bool is_parameter() const { return is_param_; }

 private:
  std::string name_;
  ast::Type *type_;
  std::size_t offset_;
  RegisterId id_;
  bool is_param_;
};

/**
 * A class that captures information about a function in the generated bytecode.
 */
class FunctionInfo {
  static constexpr const RegisterId kRVRegisterId = 0;

 public:
  FunctionInfo(FunctionId id, std::string name)
      : id_(id),
        name_(std::move(name)),
        bytecode_start_offset_(0),
        bytecode_end_offset_(0),
        frame_size_(0),
        temp_reg_id_counter_(0) {}

  RegisterId NewLocal(ast::Type *type, const std::string &name, bool is_param);
  RegisterId NewLocal(ast::Type *type);

  RegisterId LookupLocal(const std::string &name);

  constexpr RegisterId GetRVRegister() const { return kRVRegisterId; }

  void MarkBytecodeRange(std::size_t start_offset, std::size_t end_offset) {
    TPL_ASSERT(start_offset < end_offset,
               "Starting offset must be smaller than ending offset");
    bytecode_start_offset_ = start_offset;
    bytecode_end_offset_ = end_offset;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// Accessors
  ///
  //////////////////////////////////////////////////////////////////////////////

  FunctionId id() const { return id_; }

  const std::string &name() const { return name_; }

  std::size_t bytecode_start_offset() const { return bytecode_start_offset_; }

  std::size_t bytecode_end_offset() const { return bytecode_end_offset_; }

  const std::vector<Register> &locals() const { return locals_; }

  std::size_t frame_size() const { return frame_size_; }

 private:
  u32 NextTempRegId() { return ++temp_reg_id_counter_; }

 private:
  FunctionId id_;
  std::string name_;
  std::size_t bytecode_start_offset_;
  std::size_t bytecode_end_offset_;
  std::vector<Register> locals_;
  std::size_t frame_size_;

  u32 temp_reg_id_counter_;
};

}  // namespace vm
}  // namespace tpl