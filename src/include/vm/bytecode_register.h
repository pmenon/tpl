#pragma once

#include <cstdint>
#include <vector>

#include "util/bitfield.h"
#include "util/common.h"
#include "util/macros.h"

namespace tpl {

namespace ast {
class Type;
}  // namespace ast

namespace vm {

using LocalId = u16;
using FunctionId = u16;

/**
 * LocalInfo represents any local variable allocated in a function including
 * genuine local variable explicitly stated in the source, function  parameters,
 * and temporary variables required for expression evaluation.
 *
 * Locals have a fixed size, a static position (offset) in a function's
 * execution frame, and a static type. The virtual machine ensures that a
 * local variable's memory always has the correct alignment deemed by its type
 * and the machine architecture.
 */
class LocalInfo {
 public:
  enum class Kind : u8 { Var, Parameter, Temporary };

  LocalInfo(u32 index, std::string name, ast::Type *type, std::size_t offset,
            Kind kind)
      : name_(std::move(name)),
        type_(type),
        offset_(offset),
        index_(index),
        kind_(kind) {}

  std::size_t Size() const;

  const std::string &name() const { return name_; }

  const ast::Type *type() const { return type_; }

  u32 id() const { return index_; }

  std::size_t offset() const { return offset_; }

  bool is_parameter() const { return kind_ == Kind::Parameter; }

 private:
  std::string name_;
  ast::Type *type_;
  std::size_t offset_;
  u32 index_;
  Kind kind_;
};

/**
 * Local access encapsulates how a given local will be accessed by pairing a
 * local ID and an addressing mode.
 */
class LocalVar {
 public:
  // The different local addressing modes
  enum class AddressMode : u8 { Address = 0, Value = 1 };

  LocalVar() : LocalVar(kInvalidOffset, AddressMode::Address) {}

  LocalVar(u32 offset, AddressMode address_mode)
      : bitfield_(AddressModeField::Encode(address_mode) |
                  LocalOffsetField::Encode(offset)) {}

  AddressMode GetAddressMode() const {
    return AddressModeField::Decode(bitfield_);
  }

  bool IsAddressOfLocal() const {
    return GetAddressMode() == AddressMode::Address;
  }

  u32 GetOffset() const { return LocalOffsetField::Decode(bitfield_); }

  u32 Encode() const { return bitfield_; }

  static LocalVar Decode(u32 bitfield) { return LocalVar(bitfield); }

  LocalVar ValueOf() const {
    if (!IsAddressOfLocal()) {
      return *this;
    }

    return LocalVar(GetOffset(), AddressMode::Value);
  }

  bool IsInvalid() const { return GetOffset() == kInvalidOffset; }

 private:
  // Single bit indicating the addressing mode of the local
  class AddressModeField : public util::BitField32<AddressMode, 0, 1> {};

  // The offset of the local variable in the function's execution frame
  class LocalOffsetField
      : public util::BitField32<u32, AddressModeField::kNextBit, 31> {};

  static const u32 kInvalidOffset = std::numeric_limits<u32>::max() >> 1;

 private:
  explicit LocalVar(u32 bitfield) : bitfield_(bitfield) {}

 private:
  u32 bitfield_;
};

/**
 * A class that captures information about a function in the generated bytecode.
 */
class FunctionInfo {
  static const LocalId kRetVarOffset = 0;

 public:
  FunctionInfo(FunctionId id, std::string name)
      : id_(id),
        name_(std::move(name)),
        bytecode_start_offset_(0),
        bytecode_end_offset_(0),
        frame_size_(0),
        temp_id_counter_(0) {}

  LocalVar NewLocal(ast::Type *type, const std::string &name);
  LocalVar NewParameterLocal(ast::Type *type, const std::string &name);
  LocalVar NewTempLocal(ast::Type *type);

  LocalVar LookupLocal(const std::string &name);

  LocalVar GetRVLocal() const {
    return LocalVar(kRetVarOffset, LocalVar::AddressMode::Address);
  }

  void MarkBytecodeRange(std::size_t start_offset, std::size_t end_offset) {
    TPL_ASSERT(start_offset < end_offset,
               "Starting offset must be smaller than ending offset");
    bytecode_start_offset_ = start_offset;
    bytecode_end_offset_ = end_offset;
  }

  //////////////////////////////////////////////////////////////////////////////
  ///
  /// Accessors
  ///
  //////////////////////////////////////////////////////////////////////////////

  FunctionId id() const { return id_; }

  const std::string &name() const { return name_; }

  std::size_t bytecode_start_offset() const { return bytecode_start_offset_; }

  std::size_t bytecode_end_offset() const { return bytecode_end_offset_; }

  const std::vector<LocalInfo> &locals() const { return locals_; }

  std::size_t frame_size() const { return frame_size_; }

 private:
  // Allocate a new local variable in the function
  LocalVar NewLocal(ast::Type *type, const std::string &name,
                    LocalInfo::Kind kind);

  // Return the next available ID for a temporary variable
  u32 NextTempId() { return ++temp_id_counter_; }

 private:
  FunctionId id_;
  std::string name_;
  std::size_t bytecode_start_offset_;
  std::size_t bytecode_end_offset_;
  std::vector<LocalInfo> locals_;
  std::size_t frame_size_;

  u32 temp_id_counter_;
};

}  // namespace vm
}  // namespace tpl